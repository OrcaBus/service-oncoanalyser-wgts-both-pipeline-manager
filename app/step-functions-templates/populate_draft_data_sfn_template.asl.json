{
  "Comment": "A description of my state machine",
  "StartAt": "Set inputs as vars",
  "States": {
    "Set inputs as vars": {
      "Type": "Pass",
      "Next": "Validate draft data",
      "Assign": {
        "draftDetail": "{% $states.input %}",
        "draftLibrariesList": "{% $states.input.libraries %}",
        "draftPayload": "{% (\n  $states.input.payload ? \n  $states.input.payload : {\n    \"version\": \"${__default_payload_version__}\"\n  }\n) %}",
        "draftData": "{% $states.input.payload.data ? $states.input.payload.data : {} %}",
        "draftEngineParameters": "{% $states.input.payload.data.engineParameters ? $states.input.payload.data.engineParameters : {} %}",
        "draftTags": "{% $states.input.payload.data.tags ? $states.input.payload.data.tags : {} %}",
        "draftInputs": "{% $states.input.payload.data.inputs ? $states.input.payload.data.inputs : {} %}"
      }
    },
    "Validate draft data": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Output": "{% $states.result.Payload %}",
      "Arguments": {
        "FunctionName": "${__validate_draft_data_complete_schema_lambda_function_arn__}",
        "Payload": "{% $draftData %}"
      },
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "BackoffRate": 2,
          "JitterStrategy": "FULL"
        }
      ],
      "Next": "Draft data is valid"
    },
    "Draft data is valid": {
      "Type": "Choice",
      "Choices": [
        {
          "Condition": "{% $states.input.isValid %}",
          "Next": "Success"
        }
      ],
      "Default": "Get workflow object"
    },
    "Get workflow object": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Output": "{% $states.result.Payload %}",
      "Arguments": {
        "FunctionName": "${__get_workflow_run_object_lambda_function_arn__}",
        "Payload": {
          "portalRunId": "{% $draftDetail.portalRunId %}"
        }
      },
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "BackoffRate": 2,
          "JitterStrategy": "FULL"
        }
      ],
      "Next": "Do we have matching libraries",
      "Assign": {
        "draftWorkflowRunObject": "{% $states.result.Payload.workflowRunObject %}"
      }
    },
    "Do we have matching libraries": {
      "Type": "Choice",
      "Choices": [
        {
          "Comment": "All libraries in tags",
          "Next": "Get Engine parameters",
          "Condition": "{% /* https://try.jsonata.org/XDJvywd0c */\n/* Compare the draft tags to the libraries */\n/* Get the draft tags */\n(\n    [ \n        $draftTags.(normalDnaLibraryId),\n        $draftTags.(tumorDnaLibraryId),\n        $draftTags.(tumorRnaLibraryId)\n    ] ~> $sort\n)\n=\n/* Get the draft detail libraries */ \n(\n    [\n        $draftLibrariesList.(libraryId)\n    ] ~> $sort \n) %}"
        }
      ],
      "Default": "Get primitive tags from linked libraries"
    },
    "Get primitive tags from linked libraries": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Arguments": {
        "FunctionName": "${__get_libraries_lambda_function_arn__}",
        "Payload": {
          "libraries": "{% $draftLibrariesList %}"
        }
      },
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "BackoffRate": 2,
          "JitterStrategy": "FULL"
        }
      ],
      "Next": "Get Engine parameters",
      "Assign": {
        "draftTags": "{% $merge(\n  [\n    $states.result.Payload,\n    $draftTags\n  ]\n) %}"
      }
    },
    "Success": {
      "Type": "Succeed"
    },
    "Get Engine parameters": {
      "Type": "Parallel",
      "Next": "Get tags",
      "Branches": [
        {
          "StartAt": "Has Project ID",
          "States": {
            "Has Project ID": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided project id",
                  "Condition": "{% $draftEngineParameters.projectId ? true : false %}",
                  "Comment": "Project ID Provided"
                }
              ],
              "Default": "Get Default Project Id"
            },
            "Use provided project id": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "projectId": "{% $draftEngineParameters.projectId %}"
              }
            },
            "Get Default Project Id": {
              "Type": "Task",
              "Arguments": {
                "Name": "${__default_project_id_ssm_parameter_name__}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "projectId": "{% $states.result.Parameter.Value %}"
              }
            }
          }
        },
        {
          "StartAt": "Has Pipeline ID",
          "States": {
            "Has Pipeline ID": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided pipeline id",
                  "Condition": "{% ($draftEngineParameters.pipelineId ? $draftEngineParameters.pipelineId : $draftDetail.workflow.executionEnginePipelineId ) ? true : false %}",
                  "Comment": "Pipeline ID Provided"
                }
              ],
              "Default": "Get default pipeline id"
            },
            "Use provided pipeline id": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "pipelineId": "{% $draftEngineParameters.pipelineId ? $draftEngineParameters.pipelineId : $draftDetail.workflow.executionEnginePipelineId %}"
              }
            },
            "Get default pipeline id": {
              "Type": "Task",
              "Arguments": {
                "Name": "{% '${__workflow_id_to_pipeline_id_ssm_parameter_path_prefix__}/' & $draftDetail.workflow.version %}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "pipelineId": "{% $states.result.Parameter.Value %}"
              }
            }
          }
        },
        {
          "StartAt": "Has Output URI",
          "States": {
            "Has Output URI": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided output uri",
                  "Condition": "{% $draftEngineParameters.outputUri ? true : false %}",
                  "Comment": "Output URI Provided"
                }
              ],
              "Default": "Get default output uri prefix"
            },
            "Use provided output uri": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "outputUri": "{% $draftEngineParameters.outputUri %}"
              }
            },
            "Get default output uri prefix": {
              "Type": "Task",
              "Arguments": {
                "Name": "${__default_output_uri_prefix_ssm_parameter_name__}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "outputUri": "{% $states.result.Parameter.Value & $draftDetail.portalRunId & '/' %}"
              }
            }
          }
        },
        {
          "StartAt": "Has Logs URI",
          "States": {
            "Has Logs URI": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided logs uri",
                  "Condition": "{% $draftEngineParameters.logsUri ? true : false %}",
                  "Comment": "Logs URI Provided"
                }
              ],
              "Default": "Get default logs uri prefix"
            },
            "Use provided logs uri": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "logsUri": "{% $draftEngineParameters.logsUri %}"
              }
            },
            "Get default logs uri prefix": {
              "Type": "Task",
              "Arguments": {
                "Name": "${__default_logs_uri_prefix_ssm_parameter_name__}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "logsUri": "{% $states.result.Parameter.Value & $draftDetail.portalRunId & '/' %}"
              }
            }
          }
        },
        {
          "StartAt": "Has Cache URI",
          "States": {
            "Has Cache URI": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided cache uri",
                  "Condition": "{% $draftEngineParameters.cacheUri ? true : false %}",
                  "Comment": "Cache URI Provided"
                }
              ],
              "Default": "Get default cache uri prefix"
            },
            "Use provided cache uri": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "cacheUri": "{% $draftEngineParameters.cacheUri %}"
              }
            },
            "Get default cache uri prefix": {
              "Type": "Task",
              "Arguments": {
                "Name": "${__default_cache_uri_prefix_ssm_parameter_name__}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "cacheUri": "{% $states.result.Parameter.Value & $draftDetail.portalRunId & '/' %}"
              }
            }
          }
        }
      ],
      "Assign": {
        "engineParameters": "{% /* https://try.jsonata.org/6nUH8BUBr */\n [ $draftEngineParameters, $merge($states.result) ] ~> $merge  %}"
      }
    },
    "Get tags": {
      "Type": "Parallel",
      "Branches": [
        {
          "StartAt": "Has normal dna fastqRgidList",
          "States": {
            "Has normal dna fastqRgidList": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Set fastq rgid list",
                  "Condition": "{% $draftTags.normalDnaFastqRgidList ? true : false %}"
                }
              ],
              "Default": "Get fastq list rgids from normal libraries"
            },
            "Set fastq rgid list": {
              "Type": "Pass",
              "End": true,
              "Output": {}
            },
            "Get fastq list rgids from normal libraries": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Arguments": {
                "FunctionName": "${__get_fastq_rgids_from_library_id_lambda_function_arn__}",
                "Payload": {
                  "libraryId": "{% $draftTags.normalDnaLibraryId %}"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2,
                  "JitterStrategy": "FULL"
                }
              ],
              "End": true,
              "Output": {
                "normalDnaFastqRgidList": "{% $states.result.Payload.fastqRgidList %}"
              }
            }
          }
        },
        {
          "StartAt": "Has tumor dna library tag (tags)",
          "States": {
            "Has tumor dna library tag (tags)": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Tumor dna Fastq Rgid list set",
                  "Condition": "{% $draftTags.tumorDnaLibraryId ? true : false %}",
                  "Comment": "Has tumor library id"
                }
              ],
              "Default": "tumorDnaFastqRgidList is Empty"
            },
            "Tumor dna Fastq Rgid list set": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Set tumor fastq rgid list",
                  "Condition": "{% $draftTags.tumorDnaFastqRgidList ? true : false %}"
                }
              ],
              "Default": "Get fastq list rgids from tumor dna libraries"
            },
            "Set tumor fastq rgid list": {
              "Type": "Pass",
              "End": true,
              "Output": {}
            },
            "Get fastq list rgids from tumor dna libraries": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Arguments": {
                "FunctionName": "${__get_fastq_rgids_from_library_id_lambda_function_arn__}",
                "Payload": {
                  "libraryId": "{% $draftTags.tumorDnaLibraryId %}"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2,
                  "JitterStrategy": "FULL"
                }
              ],
              "End": true,
              "Output": {
                "tumorDnaFastqRgidList": "{% $states.result.Payload.fastqRgidList %}"
              }
            },
            "tumorDnaFastqRgidList is Empty": {
              "Type": "Pass",
              "Output": {},
              "End": true
            }
          }
        },
        {
          "StartAt": "Has tumor rna library tag (tags)",
          "States": {
            "Has tumor rna library tag (tags)": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Tumor rna fastq rgid list set",
                  "Condition": "{% $draftTags.tumorRnaLibraryId ? true : false %}"
                }
              ],
              "Default": "tumorRnaFastqRgidList is empty"
            },
            "Tumor rna fastq rgid list set": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Set tumor rna libraries",
                  "Condition": "{% $draftTags.tumorRnaFastqRgidList ? true : false %}"
                }
              ],
              "Default": "Get fastq list rgids from tumor rna libraries"
            },
            "Set tumor rna libraries": {
              "Type": "Pass",
              "Output": {},
              "End": true
            },
            "Get fastq list rgids from tumor rna libraries": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Output": {
                "tumorRnaFastqRgidList": "{% $states.result.Payload.fastqRgidList %}"
              },
              "Arguments": {
                "FunctionName": "${__get_fastq_rgids_from_library_id_lambda_function_arn__}",
                "Payload": {
                  "libraryId": "{% $draftTags.tumorRnaLibraryId %}"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2,
                  "JitterStrategy": "FULL"
                }
              ],
              "End": true
            },
            "tumorRnaFastqRgidList is empty": {
              "Type": "Pass",
              "End": true,
              "Output": {}
            }
          }
        },
        {
          "StartAt": "Get subject and individual id tags",
          "States": {
            "Get subject and individual id tags": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Arguments": {
                "FunctionName": "${__get_metadata_tags_lambda_function_arn__}",
                "Payload": {
                  "libraryId": "{% $draftTags.normalDnaLibraryId %}"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2,
                  "JitterStrategy": "FULL"
                }
              ],
              "End": true,
              "Output": {
                "subjectId": "{% $states.result.Payload.libraryObj.subject.subjectId %}",
                "individualId": "{% $count($states.result.Payload.libraryObj.subject.individualSet) > 0 ? $states.result.Payload.libraryObj.subject.individualSet[0].individualId : $states.result.Payload.libraryObj.subject.subjectId %}"
              }
            }
          }
        }
      ],
      "Next": "Get libraries with readsets",
      "Assign": {
        "tags": "{% /* https://try.jsonata.org/05K2l3beH */\n/* List to merge together */\n[\n    /* Start with the draft tags */\n    $draftTags,\n    /* Merge the results list together */\n    $merge($states.result)\n] \n/* Then merge these initial tags with states.result  */\n~> $merge\n/* Remove any keys with values */\n~> $sift(function($v, $k){$v != null}) %}"
      }
    },
    "Get libraries with readsets": {
      "Type": "Parallel",
      "Next": "Get inputs",
      "Branches": [
        {
          "StartAt": "For each rgid (readsets)",
          "States": {
            "For each rgid (readsets)": {
              "Type": "Map",
              "Items": "{% $tags.normalDnaFastqRgidList ? $tags.normalDnaFastqRgidList : [] %}",
              "ItemProcessor": {
                "ProcessorConfig": {
                  "Mode": "INLINE"
                },
                "StartAt": "Get readset from rgid id",
                "States": {
                  "Get readset from rgid id": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::lambda:invoke",
                    "Arguments": {
                      "FunctionName": "${__get_fastq_id_list_from_rgid_list_lambda_function_arn__}",
                      "Payload": {
                        "fastqRgidList": "{% [$states.input] %}"
                      }
                    },
                    "Retry": [
                      {
                        "ErrorEquals": [
                          "Lambda.ServiceException",
                          "Lambda.AWSLambdaException",
                          "Lambda.SdkClientException",
                          "Lambda.TooManyRequestsException"
                        ],
                        "IntervalSeconds": 1,
                        "MaxAttempts": 3,
                        "BackoffRate": 2,
                        "JitterStrategy": "FULL"
                      }
                    ],
                    "End": true,
                    "Output": {
                      "orcabusId": "{% $states.result.Payload.fastqIdList[0] %}",
                      "rgid": "{% $states.input %}"
                    }
                  }
                }
              },
              "End": true,
              "Output": {
                "library": "{% [\n  /* Draft libraries list */\n  $draftLibrariesList ~>\n  $single(function($libraryIter){\n    $libraryIter.libraryId = $tags.normalDnaLibraryId\n  }),\n  {\n    \"readsets\": $states.result\n  }\n] ~>\n$merge %}"
              }
            }
          }
        },
        {
          "StartAt": "Has tumor library tag (readsets)",
          "States": {
            "Has tumor library tag (readsets)": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Has tumor fastq ids (readsets)",
                  "Condition": "{% $tags.tumorDnaLibraryId ? true : false %}"
                }
              ],
              "Default": "tumor libraries is empty (readsets)"
            },
            "Has tumor fastq ids (readsets)": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "For each tumor dna rgid (readsets)",
                  "Condition": "{% $tags.tumorDnaFastqRgidList ? true : false %}"
                }
              ],
              "Default": "tumor libraries is empty (readsets)"
            },
            "For each tumor dna rgid (readsets)": {
              "Type": "Map",
              "Items": "{% $tags.tumorDnaFastqRgidList ? $tags.tumorDnaFastqRgidList : [] %}",
              "ItemProcessor": {
                "ProcessorConfig": {
                  "Mode": "INLINE"
                },
                "StartAt": "Get tumor dna library readsets from fastq id list",
                "States": {
                  "Get tumor dna library readsets from fastq id list": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::lambda:invoke",
                    "Output": {
                      "orcabusId": "{% $states.result.Payload.fastqIdList[0] %}",
                      "rgid": "{% $states.input %}"
                    },
                    "Arguments": {
                      "FunctionName": "${__get_fastq_id_list_from_rgid_list_lambda_function_arn__}",
                      "Payload": {
                        "fastqRgidList": "{% [$states.input] %}"
                      }
                    },
                    "Retry": [
                      {
                        "ErrorEquals": [
                          "Lambda.ServiceException",
                          "Lambda.AWSLambdaException",
                          "Lambda.SdkClientException",
                          "Lambda.TooManyRequestsException"
                        ],
                        "IntervalSeconds": 1,
                        "MaxAttempts": 3,
                        "BackoffRate": 2,
                        "JitterStrategy": "FULL"
                      }
                    ],
                    "End": true
                  }
                }
              },
              "End": true,
              "Output": {
                "library": "{% [\n  /* Draft libraries list */\n  $draftLibrariesList ~>\n  $single(function($libraryIter){\n    $libraryIter.libraryId = $tags.tumorDnaLibraryId \n  }),\n  {\n    \"readsets\": $states.result\n  }\n] ~>\n$merge %}"
              }
            },
            "tumor libraries is empty (readsets)": {
              "Type": "Pass",
              "End": true,
              "Output": {}
            }
          }
        },
        {
          "StartAt": "Has tumor rna tag (readsets)",
          "States": {
            "Has tumor rna tag (readsets)": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Has tumor rna fastq ids (readsets)",
                  "Condition": "{% $tags.tumorRnaLibraryId ? true : false %}"
                }
              ],
              "Default": "tumor rna libraries is empty (readsets)"
            },
            "Has tumor rna fastq ids (readsets)": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "For each tumor rna rgid (readsets)",
                  "Condition": "{% $tags.tumorRnaFastqRgidList ? true : false %}"
                }
              ],
              "Default": "tumor rna libraries is empty (readsets)"
            },
            "For each tumor rna rgid (readsets)": {
              "Type": "Map",
              "ItemProcessor": {
                "ProcessorConfig": {
                  "Mode": "INLINE"
                },
                "StartAt": "Get tumor rna library readsets from fastq id list",
                "States": {
                  "Get tumor rna library readsets from fastq id list": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::lambda:invoke",
                    "Output": {
                      "orcabusId": "{% $states.result.Payload.fastqIdList[0] %}",
                      "rgid": "{% $states.input %}"
                    },
                    "Arguments": {
                      "FunctionName": "${__get_fastq_id_list_from_rgid_list_lambda_function_arn__}",
                      "Payload": {
                        "fastqRgidList": "{% [$states.input] %}"
                      }
                    },
                    "Retry": [
                      {
                        "ErrorEquals": [
                          "Lambda.ServiceException",
                          "Lambda.AWSLambdaException",
                          "Lambda.SdkClientException",
                          "Lambda.TooManyRequestsException"
                        ],
                        "IntervalSeconds": 1,
                        "MaxAttempts": 3,
                        "BackoffRate": 2,
                        "JitterStrategy": "FULL"
                      }
                    ],
                    "End": true
                  }
                }
              },
              "End": true,
              "Output": {
                "library": "{% [\n  /* Draft libraries list */\n  $draftLibrariesList ~>\n  $single(function($libraryIter){\n    $libraryIter.libraryId = $tags.tumorRnaLibraryId \n  }),\n  {\n    \"readsets\": $states.result\n  }\n] ~>\n$merge %}"
              },
              "Items": "{% $tags.tumorRnaFastqRgidList ? $tags.tumorRnaFastqRgidList : [] %}"
            },
            "tumor rna libraries is empty (readsets)": {
              "Type": "Pass",
              "End": true
            }
          }
        }
      ],
      "Assign": {
        "libraries": "{% $states.result.(library) %}"
      }
    },
    "Get inputs": {
      "Type": "Parallel",
      "Branches": [
        {
          "StartAt": "Has oncoanalyser wgts dna data",
          "States": {
            "Has oncoanalyser wgts dna data": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Keep Original data (DNA)",
                  "Condition": "{% ($draftInputs.tumorDnaInputs ? true : false) or ($draftInputs.normalDnaInputs ? true : false) %}"
                }
              ],
              "Default": "Get oncoanalyser wgts dna succeeded event"
            },
            "Get oncoanalyser wgts dna succeeded event": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Assign": {
                "upstreamWorkflowRunObject": "{% $states.result.Payload.workflowRunObject %}"
              },
              "Arguments": {
                "FunctionName": "${__find_latest_workflow_lambda_function_arn__}",
                "Payload": {
                  "workflowName": "${__oncoanalyser_wgts_dna_workflow_name__}",
                  "libraries": "{% [\n  $libraries ~>\n  $filter(function($v){\n    $v.libraryId in [$draftTags.tumorDnaLibraryId, $draftTags.normalDnaLibraryId]\n  })\n] %}",
                  "analysisRunId": "{% $draftWorkflowRunObject.analysisRun ? $draftWorkflowRunObject.analysisRun.orcabusId : null %}",
                  "status": "${__succeeded_status__}"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2,
                  "JitterStrategy": "FULL"
                }
              ],
              "Next": "Oncoanalyser WGTS DNA succeeded workflow found"
            },
            "Oncoanalyser WGTS DNA succeeded workflow found": {
              "Type": "Choice",
              "Choices": [
                {
                  "Condition": "{% $upstreamWorkflowRunObject ? true : false %}",
                  "Next": "Get dna inputs"
                }
              ],
              "Default": "No oncoanalyser WGTS DNA output data found"
            },
            "Get dna inputs": {
              "Type": "Parallel",
              "End": true,
              "Branches": [
                {
                  "StartAt": "Get normal dna inputs from portal run id",
                  "States": {
                    "Get normal dna inputs from portal run id": {
                      "Type": "Task",
                      "Resource": "arn:aws:states:::lambda:invoke",
                      "Output": {
                        "normalDnaInputs": "{% $states.result.Payload.normalDnaInputs %}"
                      },
                      "Arguments": {
                        "FunctionName": "${__get_oncoanalyser_wgts_outputs_from_portal_run_id_lambda_function_arn__}",
                        "Payload": {
                          "portalRunId": "{% $upstreamWorkflowRunObject.portalRunId %}",
                          "phenotype": "NORMAL",
                          "sampleType": "DNA",
                          "tumorDnaLibraryId": "{% $tags.tumorDnaLibraryId %}",
                          "normalDnaLibraryId": "{% $tags.normalDnaLibraryId %}"
                        }
                      },
                      "Retry": [
                        {
                          "ErrorEquals": [
                            "Lambda.ServiceException",
                            "Lambda.AWSLambdaException",
                            "Lambda.SdkClientException",
                            "Lambda.TooManyRequestsException"
                          ],
                          "IntervalSeconds": 1,
                          "MaxAttempts": 3,
                          "BackoffRate": 2,
                          "JitterStrategy": "FULL"
                        }
                      ],
                      "End": true
                    }
                  }
                },
                {
                  "StartAt": "Has tumor rgid list",
                  "States": {
                    "Has tumor rgid list": {
                      "Type": "Choice",
                      "Choices": [
                        {
                          "Next": "Get tumor dna inputs from portal run id",
                          "Condition": "{% $tags.tumorDnaFastqRgidList ? true : false %}"
                        }
                      ],
                      "Default": "Pass"
                    },
                    "Pass": {
                      "Type": "Pass",
                      "End": true,
                      "Output": {}
                    },
                    "Get tumor dna inputs from portal run id": {
                      "Type": "Task",
                      "Resource": "arn:aws:states:::lambda:invoke",
                      "Output": {
                        "tumorDnaInputs": "{% $states.result.Payload.tumorDnaInputs %}"
                      },
                      "Arguments": {
                        "FunctionName": "${__get_oncoanalyser_wgts_outputs_from_portal_run_id_lambda_function_arn__}",
                        "Payload": {
                          "portalRunId": "{% $upstreamWorkflowRunObject.portalRunId %}",
                          "phenotype": "TUMOR",
                          "sampleType": "DNA",
                          "tumorDnaLibraryId": "{% $tags.tumorDnaLibraryId %}",
                          "normalDnaLibraryId": "{% $tags.normalDnaLibraryId %}"
                        }
                      },
                      "Retry": [
                        {
                          "ErrorEquals": [
                            "Lambda.ServiceException",
                            "Lambda.AWSLambdaException",
                            "Lambda.SdkClientException",
                            "Lambda.TooManyRequestsException"
                          ],
                          "IntervalSeconds": 1,
                          "MaxAttempts": 3,
                          "BackoffRate": 2,
                          "JitterStrategy": "FULL"
                        }
                      ],
                      "End": true
                    }
                  }
                }
              ],
              "Output": "{% $states.result ~> $merge %}"
            },
            "No oncoanalyser WGTS DNA output data found": {
              "Type": "Pass",
              "End": true,
              "Output": {}
            },
            "Keep Original data (DNA)": {
              "Type": "Pass",
              "End": true,
              "Output": {}
            }
          }
        },
        {
          "StartAt": "Has oncoanalyser WGTS RNA data",
          "States": {
            "Has oncoanalyser WGTS RNA data": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Keep Original data (RNA)",
                  "Condition": "{% $draftInputs.tumorRnaInputs ? true : false %}"
                }
              ],
              "Default": "Get oncoanalyser wgts rna succeeded event"
            },
            "Keep Original data (RNA)": {
              "Type": "Pass",
              "Output": {},
              "End": true
            },
            "Get oncoanalyser wgts rna succeeded event": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Output": "{% $states.result.Payload %}",
              "Arguments": {
                "FunctionName": "${__find_latest_workflow_lambda_function_arn__}",
                "Payload": {
                  "workflowName": "${__oncoanalyser_wgts_rna_workflow_name__}",
                  "libraries": "{% [\n  $libraries ~>\n  $filter(function($v){\n    $v.libraryId in [$draftTags.tumorRnaLibraryId]\n  })\n] %}",
                  "analysisRunId": "{% $draftWorkflowRunObject.analysisRun ? $draftWorkflowRunObject.analysisRun.orcabusId : null %}",
                  "status": "${__succeeded_status__}"
                }
              },
              "Retry": [
                {
                  "ErrorEquals": [
                    "Lambda.ServiceException",
                    "Lambda.AWSLambdaException",
                    "Lambda.SdkClientException",
                    "Lambda.TooManyRequestsException"
                  ],
                  "IntervalSeconds": 1,
                  "MaxAttempts": 3,
                  "BackoffRate": 2,
                  "JitterStrategy": "FULL"
                }
              ],
              "Assign": {
                "upstreamWorkflowRunObject": "{% $states.result.Payload.workflowRunObject %}"
              },
              "Next": "Oncoanalyser WGTS RNA succeeded workflow found"
            },
            "Oncoanalyser WGTS RNA succeeded workflow found": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Get RNA inputs",
                  "Condition": "{% $upstreamWorkflowRunObject ? true : false %}"
                }
              ],
              "Default": "No oncoanalyser wgts rna data found"
            },
            "Get RNA inputs": {
              "Type": "Parallel",
              "Output": "{% $states.result ~> $merge %}",
              "End": true,
              "Branches": [
                {
                  "StartAt": "Get tumor rna inputs from portal run id",
                  "States": {
                    "Get tumor rna inputs from portal run id": {
                      "Type": "Task",
                      "Resource": "arn:aws:states:::lambda:invoke",
                      "Output": {
                        "tumorRnaInputs": "{% $states.result.Payload.tumorRnaInputs %}"
                      },
                      "Arguments": {
                        "FunctionName": "${__get_oncoanalyser_wgts_outputs_from_portal_run_id_lambda_function_arn__}",
                        "Payload": {
                          "portalRunId": "{% $upstreamWorkflowRunObject.portalRunId %}",
                          "phenotype": "TUMOR",
                          "sampleType": "RNA",
                          "tumorRnaLibraryId": "{% $tags.tumorRnaLibraryId %}"
                        }
                      },
                      "Retry": [
                        {
                          "ErrorEquals": [
                            "Lambda.ServiceException",
                            "Lambda.AWSLambdaException",
                            "Lambda.SdkClientException",
                            "Lambda.TooManyRequestsException"
                          ],
                          "IntervalSeconds": 1,
                          "MaxAttempts": 3,
                          "BackoffRate": 2,
                          "JitterStrategy": "FULL"
                        }
                      ],
                      "End": true
                    }
                  }
                },
                {
                  "StartAt": "Placeholder (RNA inputs)",
                  "States": {
                    "Placeholder (RNA inputs)": {
                      "Type": "Pass",
                      "Output": {},
                      "End": true
                    }
                  }
                }
              ]
            },
            "No oncoanalyser wgts rna data found": {
              "Type": "Pass",
              "End": true
            }
          }
        },
        {
          "StartAt": "Get default input params",
          "States": {
            "Get default input params": {
              "Type": "Task",
              "Arguments": {
                "Name": "{% '${__default_inputs_ssm_parameter_prefix__}/' & $draftDetail.workflow.version %}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "Output": "{% $parse($states.result.Parameter.Value) %}",
              "End": true
            }
          }
        }
      ],
      "Next": "Add reference data",
      "Assign": {
        "draftInputs": "{% /* https://try.jsonata.org/ZAkTIin-h */\n[\n  /* Start with the default input params */\n  $states.result[2],\n  /* Then take what weve got in the draft inputs */\n  $draftInputs,\n  /* Combine the states results for the oncoanalyser dna+rna outputs */\n  (\n   [\n     $states.result[0],\n     $states.result[1]\n   ] ~> $merge\n  ),\n  /* Add in the required sampleName and tumorSampleName */\n  /* These must match the value of the library id */\n  {\n    \"normalDnaSampleId\": $draftTags.normalDnaLibraryId,\n    \"tumorDnaSampleId\": $draftTags.tumorDnaLibraryId ? $draftTags.tumorDnaLibraryId : null,\n    \"tumorRnaSampleId\": $draftTags.tumorRnaLibraryId ? $draftTags.tumorRnaLibraryId : null\n  },\n  /* We also add in the groupId and subjectId if theyre not already in */\n  {\n    \"groupId\": (\n        $draftInputs.groupId ? $draftInputs.groupId : (\n            ( $draftTags.tumorDnaLibraryId ? $draftTags.tumorDnaLibraryId & \"__\": \"\" ) & \n            $draftTags.normalDnaLibraryId & \n            ( $draftTags.tumorRnaLibraryId ? \"__\" & $draftTags.tumorRnaLibraryId : \"\" )\n        )\n    ),\n    \"subjectId\": (\n        $draftInputs.subjectId ? $draftInputs.subjectId : (\n            ( $draftTags.tumorDnaLibraryId ? $draftTags.tumorDnaLibraryId & \"__\": \"\" ) &\n            $draftTags.normalDnalibraryId & \n            ( $draftTags.tumorRnaLibraryId ? \"__\" & $draftTags.tumorRnaLibraryId : \"\" )\n        )\n    )\n  }\n]\n/* Combine list of objects */\n~> $merge\n/* Sift out inputs with null values */\n~> $sift(function($v, $k){ $v != null }) %}"
      }
    },
    "Add reference data": {
      "Type": "Parallel",
      "Next": "Make new WRU event",
      "Branches": [
        {
          "StartAt": "Hmf Reference data provided",
          "States": {
            "Hmf Reference data provided": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Use provided oncoanalyser wgts dna ref data path",
                  "Condition": "{% $draftInputs.refDataHmfDataPath ? true : false %}"
                }
              ],
              "Default": "Use default oncoanalyser wgts dna ref data path"
            },
            "Use provided oncoanalyser wgts dna ref data path": {
              "Type": "Pass",
              "End": true,
              "Output": {
                "refDataHmfDataPath": "{% $draftInputs.refDataHmfDataPath %}"
              }
            },
            "Use default oncoanalyser wgts dna ref data path": {
              "Type": "Task",
              "Arguments": {
                "Name": "{% '${__default_hmf_reference_data_path_ssm_parameter_prefix__}/' & $draftDetail.workflow.version %}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "refDataHmfDataPath": "{% $parse($states.result.Parameter.Value) %}"
              }
            }
          }
        },
        {
          "StartAt": "Using non-hmf reference genome",
          "States": {
            "Using non-hmf reference genome": {
              "Type": "Choice",
              "Choices": [
                {
                  "Next": "Get genome parameter",
                  "Condition": "{% ( ( $draftInputs.genome ~> $match(/_hmf$/) ) ? true : false ) ~> $not %}"
                }
              ],
              "Default": "Refdata placeholder"
            },
            "Get genome parameter": {
              "Type": "Task",
              "Arguments": {
                "Name": "{% '${__default_genome_ssm_parameter_prefix__}/' & $draftInputs.genome %}"
              },
              "Resource": "arn:aws:states:::aws-sdk:ssm:getParameter",
              "End": true,
              "Output": {
                "genomes": "{% {\n  $draftInputs.genome: $parse($states.result.Parameter.Value)\n} %}"
              }
            },
            "Refdata placeholder": {
              "Type": "Pass",
              "End": true,
              "Output": {}
            }
          }
        }
      ],
      "Assign": {
        "draftInputs": "{% [\n  /* Start with the draft inputs + sequence data inputs */\n  $draftInputs,\n  /* Combine the states results */\n  $merge($states.result)\n] \n/* Merge Old and new */\n~> $merge\n/* Sift out inputs with null values */\n~> $sift(function($v, $k){ $v != null }) %}"
      }
    },
    "Make new WRU event": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Output": "{% $states.result.Payload %}",
      "Arguments": {
        "FunctionName": "${__generate_wru_event_object_with_merged_data_lambda_function_arn__}",
        "Payload": {
          "portalRunId": "{% $draftDetail.portalRunId %}",
          "libraries": "{% $libraries %}",
          "payload": {
            "version": "{% $draftPayload.version ? $draftPayload.version : '${__default_payload_version__}' %}",
            "data": {
              "inputs": "{% $draftInputs %}",
              "tags": "{% $tags %}",
              "engineParameters": "{% $engineParameters %}"
            }
          }
        }
      },
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "BackoffRate": 2,
          "JitterStrategy": "FULL"
        }
      ],
      "Next": "Compare payload",
      "Assign": {
        "draftWorkflowRunUpdate": "{% $states.result.Payload.workflowRunUpdate %}"
      }
    },
    "Compare payload": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Output": "{% $states.result.Payload %}",
      "Arguments": {
        "FunctionName": "${__compare_payload_lambda_function_arn__}",
        "Payload": {
          "oldPayload": "{% $draftPayload ~> \n| $ | {}, [\"orcabusId\", \"refId\"] | %}",
          "newPayload": "{% $draftWorkflowRunUpdate.payload %}"
        }
      },
      "Retry": [
        {
          "ErrorEquals": [
            "Lambda.ServiceException",
            "Lambda.AWSLambdaException",
            "Lambda.SdkClientException",
            "Lambda.TooManyRequestsException"
          ],
          "IntervalSeconds": 1,
          "MaxAttempts": 3,
          "BackoffRate": 2,
          "JitterStrategy": "FULL"
        }
      ],
      "Next": "Has changed"
    },
    "Has changed": {
      "Type": "Choice",
      "Choices": [
        {
          "Next": "New workflow manager deployed",
          "Condition": "{% $states.input.hasChanged %}",
          "Comment": "Payload has changed"
        }
      ],
      "Default": "Skip push event"
    },
    "New workflow manager deployed": {
      "Type": "Choice",
      "Choices": [
        {
          "Condition": "{% ${__new_workflow_manager_is_deployed__} %}",
          "Comment": "New Workflow Manager is Deployed",
          "Next": "Put DRAFT update event"
        }
      ],
      "Default": "Push DRAFT Event (legacy)"
    },
    "Put DRAFT update event": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Arguments": {
        "Entries": [
          {
            "Detail": "{% $merge([\n  $draftWorkflowRunUpdate,\n  {\n    \"timestamp\": $states.context.State.EnteredTime }\n])\n/* Remove null inputs like id */\n~> $sift(function($v, $k){$v != null}) %}",
            "DetailType": "${__workflow_run_update_event_detail_type__}",
            "EventBusName": "${__event_bus_name__}",
            "Source": "${__stack_source__}"
          }
        ]
      },
      "End": true
    },
    "Skip push event": {
      "Type": "Pass",
      "End": true
    },
    "Push DRAFT Event (legacy)": {
      "Type": "Task",
      "Resource": "arn:aws:states:::events:putEvents",
      "Arguments": {
        "Entries": [
          {
            "Detail": "{% /* https://try.jsonata.org/r0aCmiix- */\n$merge([\n  $draftWorkflowRunUpdate,\n  {\n    \"timestamp\": $states.context.State.EnteredTime,\n    \"libraries\": ($libraries ~> | $ | {}, [\"readsets\"] |)\n  }\n]) ~>\n/* Renamed libraries to linkedLibraries using the transform method */\n| $ | {\"linkedLibraries\": libraries}, [\"libraries\"] | ~>\n/* Renamed workflowName and workflowVersion using the transform method */\n| $ | {\"workflowName\": workflow.name, \"workflowVersion\": workflow.version}, [\"workflow\"] | %}",
            "DetailType": "${__workflow_run_state_change_event_detail_type__}",
            "EventBusName": "${__event_bus_name__}",
            "Source": "${__stack_source__}"
          }
        ]
      },
      "End": true
    }
  },
  "QueryLanguage": "JSONata"
}
